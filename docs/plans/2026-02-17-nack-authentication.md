# NACK Authentication Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Enable NACK (JetStream controller) to authenticate with the NATS server using pre-signed credentials generated by a new `--generate-credentials` CLI command.

**Architecture:** Promote the APP account identity key to KMS (stable across restarts). Add a `--generate-credentials` command that fetches/creates this KMS key, generates a NACK user keypair locally, signs a user JWT with JetStream permissions, and writes a `.creds` file. Modify the auth service to use the KMS-backed APP account key instead of an ephemeral one when the alias is configured.

**Tech Stack:** Go, AWS KMS (Ed25519), NATS JWT v2, nkeys

---

### Task 1: Add NACK user JWT creation function with tests

**Files:**
- Create: `cmd/server/credentials.go`
- Create: `cmd/server/credentials_test.go`

**Step 1: Write the failing test for NACK user claims creation**

In `cmd/server/credentials_test.go`:

```go
// SPDX-License-Identifier: Apache-2.0
// Copyright 2026 nats-aws-auth contributors

package main

import (
	"testing"

	"github.com/nats-io/jwt/v2"
	"github.com/nats-io/nkeys"
)

func TestCreateNackUserClaims(t *testing.T) {
	// Create a local account keypair to act as the APP account (stands in for KMS in tests)
	accountKP, err := nkeys.CreateAccount()
	if err != nil {
		t.Fatalf("failed to create account keypair: %v", err)
	}
	accountPubKey, _ := accountKP.PublicKey()

	userKP, err := nkeys.CreateUser()
	if err != nil {
		t.Fatalf("failed to create user keypair: %v", err)
	}
	userPubKey, _ := userKP.PublicKey()

	claims := createNackUserClaims(userPubKey, accountPubKey)

	// Verify basic fields
	if claims.Name != "nack" {
		t.Errorf("expected name 'nack', got %q", claims.Name)
	}
	if claims.IssuerAccount != accountPubKey {
		t.Errorf("expected issuer account %s, got %s", accountPubKey, claims.IssuerAccount)
	}
	if claims.Subject != userPubKey {
		t.Errorf("expected subject %s, got %s", userPubKey, claims.Subject)
	}

	// Verify JetStream API permissions
	expectedPub := []string{"$JS.API.>"}
	expectedSub := []string{"$JS.API.>", "_INBOX.>"}

	if len(claims.Pub.Allow) != len(expectedPub) {
		t.Fatalf("expected %d pub allows, got %d", len(expectedPub), len(claims.Pub.Allow))
	}
	for i, v := range expectedPub {
		if string(claims.Pub.Allow[i]) != v {
			t.Errorf("pub allow[%d]: expected %q, got %q", i, v, claims.Pub.Allow[i])
		}
	}

	if len(claims.Sub.Allow) != len(expectedSub) {
		t.Fatalf("expected %d sub allows, got %d", len(expectedSub), len(claims.Sub.Allow))
	}
	for i, v := range expectedSub {
		if string(claims.Sub.Allow[i]) != v {
			t.Errorf("sub allow[%d]: expected %q, got %q", i, v, claims.Sub.Allow[i])
		}
	}
}

func TestCreateNackUserClaims_CanEncode(t *testing.T) {
	accountKP, _ := nkeys.CreateAccount()
	accountPubKey, _ := accountKP.PublicKey()
	userKP, _ := nkeys.CreateUser()
	userPubKey, _ := userKP.PublicKey()

	claims := createNackUserClaims(userPubKey, accountPubKey)

	// Encode with the account keypair (simulates what KMS signing does)
	token, err := claims.Encode(accountKP)
	if err != nil {
		t.Fatalf("failed to encode claims: %v", err)
	}

	// Decode and verify round-trip
	decoded, err := jwt.DecodeUserClaims(token)
	if err != nil {
		t.Fatalf("failed to decode token: %v", err)
	}
	if decoded.Name != "nack" {
		t.Errorf("decoded name: expected 'nack', got %q", decoded.Name)
	}
	if decoded.IssuerAccount != accountPubKey {
		t.Errorf("decoded issuer account mismatch")
	}
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./cmd/server/ -run TestCreateNackUser -v`
Expected: FAIL — `createNackUserClaims` undefined

**Step 3: Write minimal implementation**

In `cmd/server/credentials.go`:

```go
// SPDX-License-Identifier: Apache-2.0
// Copyright 2026 nats-aws-auth contributors

package main

import (
	"time"

	"github.com/nats-io/jwt/v2"
)

// createNackUserClaims builds user claims for the NACK JetStream controller
// with $JS.API.> pub/sub permissions and _INBOX.> sub permissions.
func createNackUserClaims(userPubKey, accountPubKey string) *jwt.UserClaims {
	claims := jwt.NewUserClaims(userPubKey)
	claims.Name = "nack"
	claims.IssuedAt = time.Now().Unix()
	claims.IssuerAccount = accountPubKey

	claims.Permissions = jwt.Permissions{
		Pub: jwt.Permission{
			Allow: []string{"$JS.API.>"},
		},
		Sub: jwt.Permission{
			Allow: []string{"$JS.API.>", "_INBOX.>"},
		},
	}

	return claims
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./cmd/server/ -run TestCreateNackUser -v`
Expected: PASS (2 tests)

**Step 5: Commit**

```bash
git add cmd/server/credentials.go cmd/server/credentials_test.go
git commit -m "feat: add NACK user JWT claims creation with tests"
```

---

### Task 2: Add credentials formatting function with tests

**Files:**
- Modify: `cmd/server/credentials.go`
- Modify: `cmd/server/credentials_test.go`

**Step 1: Write the failing test for credential formatting**

Append to `cmd/server/credentials_test.go`:

```go
func TestFormatCredentials(t *testing.T) {
	result := formatCredentials("eyJhbGciOiJFZDI1NTE5In0.test", "SUAM_test_seed")

	// Check structure markers
	if !strings.Contains(result, "-----BEGIN NATS USER JWT-----") {
		t.Error("missing JWT begin marker")
	}
	if !strings.Contains(result, "------END NATS USER JWT------") {
		t.Error("missing JWT end marker")
	}
	if !strings.Contains(result, "-----BEGIN USER NKEY SEED-----") {
		t.Error("missing seed begin marker")
	}
	if !strings.Contains(result, "------END USER NKEY SEED------") {
		t.Error("missing seed end marker")
	}
	if !strings.Contains(result, "eyJhbGciOiJFZDI1NTE5In0.test") {
		t.Error("JWT not found in output")
	}
	if !strings.Contains(result, "SUAM_test_seed") {
		t.Error("seed not found in output")
	}
}
```

Add `"strings"` to the imports in the test file.

**Step 2: Run test to verify it fails**

Run: `go test ./cmd/server/ -run TestFormatCredentials -v`
Expected: FAIL — `formatCredentials` undefined

**Step 3: Write minimal implementation**

Append to `cmd/server/credentials.go`:

```go
import "fmt"

// formatCredentials produces a NATS .creds file from a JWT and nkey seed.
func formatCredentials(userJWT, seed string) string {
	return fmt.Sprintf(`-----BEGIN NATS USER JWT-----
%s
------END NATS USER JWT------

-----BEGIN USER NKEY SEED-----
%s
------END USER NKEY SEED------
`, userJWT, seed)
}
```

Note: merge the `"fmt"` import into the existing import block alongside `"time"`.

**Step 4: Run test to verify it passes**

Run: `go test ./cmd/server/ -run TestFormatCredentials -v`
Expected: PASS

**Step 5: Commit**

```bash
git add cmd/server/credentials.go cmd/server/credentials_test.go
git commit -m "feat: add credentials file formatting with tests"
```

---

### Task 3: Wire up `--generate-credentials` CLI command

**Files:**
- Modify: `cmd/server/main.go` — add flag and command dispatch
- Modify: `cmd/server/credentials.go` — add `runGenerateCredentials` orchestrator

**Step 1: Add the flag and command dispatch in main.go**

In `cmd/server/main.go`, add a new flag alongside the existing `generate` flag:

```go
var generateCreds = flag.Bool("generate-credentials", false, "Generate NACK credentials file and exit")
```

Add a new flag for the APP account KMS alias (used by both `--generate-credentials` and the auth service):

```go
var appAccountKeyAlias = flag.String("app-account-key-alias", "", "KMS key alias for APP account (e.g. 'nats-app-account'). When set, uses a stable KMS-backed key for the APP account identity")
```

Update the command dispatch in `main()` to handle the new command. After `flag.Parse()`, the dispatch becomes:

```go
if *generate {
    runGenerate(ctx, *operatorName, *sysAccountName, *authAccountName, *region, *outputDir, *aliasPrefix)
} else if *generateCreds {
    if *appAccountKeyAlias == "" {
        log.Fatal("--app-account-key-alias is required for --generate-credentials")
    }
    runGenerateCredentials(ctx, *region, *appAccountKeyAlias, *outputDir)
} else {
    authorizer := initAuthorizer(ctx, *authBackend, *jwksURL, *jwksPath, *jwtIssuer, *jwtAudience)
    runAuthService(ctx, *authAccountName, *appAccountName, *region, *natsURL, *appAccountKeyAlias, authorizer)
}
```

Note: `runAuthService` gains a new `appAccountKeyAlias string` parameter — this is wired in Task 4.
For now, just add the parameter to the call site; the function signature change happens in Task 4.

**Step 2: Implement `runGenerateCredentials` in credentials.go**

Add to `cmd/server/credentials.go`:

```go
import (
	"context"
	"log"
	"os"

	"github.com/nats-io/nkeys"
)

// runGenerateCredentials generates NACK credentials signed by the APP account KMS key.
func runGenerateCredentials(ctx context.Context, region, appAccountKeyAlias, outputDir string) {
	client := setupAWSClient(ctx, region)

	log.Println("Generating NACK credentials...")
	log.Println()

	// Step 1: Get or create APP account key in KMS
	log.Printf("Step 1: Getting/creating APP account key in KMS (alias: %s)...", appAccountKeyAlias)
	appAccountKey, appExisted, err := getOrCreateKMSKey(ctx, client, nkeys.PrefixByteAccount, appAccountKeyAlias)
	if err != nil {
		log.Fatalf("Failed to get/create APP account key: %v", err)
	}
	logKeyStatus("APP Account", appAccountKey, appExisted)

	// Step 2: Generate NACK user keypair
	log.Println("Step 2: Generating NACK user keypair...")
	nackKey, err := createLocalKey(nkeys.PrefixByteUser)
	if err != nil {
		log.Fatalf("Failed to create NACK user key: %v", err)
	}
	log.Printf("  NACK User Public Key: %s", nackKey.PublicKey)
	log.Println()

	// Step 3: Create NACK user JWT signed by APP account key via KMS
	log.Println("Step 3: Creating NACK user JWT (signed by APP account via KMS)...")
	nackClaims := createNackUserClaims(nackKey.PublicKey, appAccountKey.PublicKey)
	appAccountKP := &dummyKeyPair{pubKey: appAccountKey.PublicKey}
	appAccountSigner := createKMSSigner(ctx, client, appAccountKey.KeyID)

	nackJWT, err := nackClaims.EncodeWithSigner(appAccountKP, appAccountSigner)
	if err != nil {
		log.Fatalf("Failed to encode NACK user JWT: %v", err)
	}
	log.Println("  NACK user JWT created successfully")
	log.Println()

	// Step 4: Write credentials file
	log.Println("Step 4: Writing NACK credentials file...")
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		log.Fatalf("Failed to create output directory: %v", err)
	}

	credsContent := formatCredentials(nackJWT, nackKey.Seed)
	credsPath := outputDir + "/nack.creds"
	if err := os.WriteFile(credsPath, []byte(credsContent), 0600); err != nil {
		log.Fatalf("Failed to write NACK credentials: %v", err)
	}
	log.Printf("  NACK credentials written to: %s", credsPath)
	log.Println()

	log.Println("Credential generation complete!")
	log.Println()
	log.Println("Generated files:")
	log.Printf("  - %s/nack.creds   (NACK JetStream controller credentials)", outputDir)
}
```

Note: merge all new imports into the existing import block.

**Step 3: Verify it compiles**

Run: `go build ./cmd/server/`

This will fail because `runAuthService` signature doesn't yet accept `appAccountKeyAlias`. Temporarily, to make it compile, update the `runAuthService` signature in `authservice.go` to accept the new parameter (ignored for now):

Change the function signature at `authservice.go:42`:
```go
func runAuthService(ctx context.Context, authAccountName, appAccountName, region, natsURL, appAccountKeyAlias string, authorizer auth.Authorizer) {
```

The `appAccountKeyAlias` parameter is unused for now — that's wired in Task 4.

**Step 4: Run all tests to verify nothing is broken**

Run: `go test ./... -v`
Expected: All existing tests pass, plus the 3 new tests from Tasks 1-2

**Step 5: Commit**

```bash
git add cmd/server/main.go cmd/server/credentials.go cmd/server/authservice.go
git commit -m "feat: add --generate-credentials command for NACK creds"
```

---

### Task 4: Modify auth service to use KMS-backed APP account key

**Files:**
- Modify: `cmd/server/authservice.go` — change `ensureAppAccountExists` and threading

The auth service needs to use the stable KMS key for the APP account identity when `--app-account-key-alias` is provided. When it's empty, fall back to current ephemeral behaviour.

**Step 1: Add APP account KMS key lookup in setupNATSConnection**

The KMS lookup needs to happen early so it's available to `fetchAndConfigureAccounts`. Add a new function in `authservice.go`:

```go
func lookupAppAccountKey(ctx context.Context, client *kms.Client, alias string) *KMSKey {
	log.Printf("Looking up APP account key from KMS (alias: %s)...", alias)
	appKey, err := getExistingKMSKey(ctx, client, "alias/"+alias, nkeys.PrefixByteAccount)
	if err != nil {
		log.Fatalf("Failed to find APP account key in KMS: %v\n\nPlease run with --generate-credentials first to create the KMS key.", err)
	}
	log.Printf("  APP Account Public Key: %s", appKey.PublicKey)
	log.Printf("  KMS Key ID: %s", appKey.KeyID)
	log.Println()
	return appKey
}
```

**Step 2: Thread the APP account KMS key through the auth service**

Modify `runAuthService` to optionally look up the APP account key and pass it through:

```go
func runAuthService(ctx context.Context, authAccountName, appAccountName, region, natsURL, appAccountKeyAlias string, authorizer auth.Authorizer) {
	log.Println("NATS Client with KMS-signed credentials")
	log.Println()

	client := setupAWSForAuthService(ctx, region)
	conn := setupNATSConnection(ctx, client, natsURL)
	defer conn.nc.Close()

	// Look up APP account KMS key if alias provided
	var appAccountKey *KMSKey
	if appAccountKeyAlias != "" {
		appAccountKey = lookupAppAccountKey(ctx, client, appAccountKeyAlias)
	}

	accounts := fetchAndConfigureAccounts(ctx, client, conn, authAccountName, appAccountName, appAccountKey)

	startAuthService(conn.nc, accounts, authAccountName, appAccountName, natsURL, authorizer)
}
```

Update `fetchAndConfigureAccounts` signature to accept `appAccountKey *KMSKey`:

```go
func fetchAndConfigureAccounts(ctx context.Context, client *kms.Client, conn *natsConnection, authAccountName, appAccountName string, appAccountKey *KMSKey) *accountConfig {
	signingKP := generateSigningKeyPair()
	authJWT, appJWT := fetchAccountsFromNATS(conn.nc, authAccountName, appAccountName)

	appClaims := ensureAppAccountExists(conn, appJWT, appAccountName, appAccountKey)
	authClaims := decodeAuthAccount(authJWT, authAccountName)

	authUserKP := createAuthUserKeyPair()

	updateAuthAccount(conn, authClaims, signingKP, authUserKP)
	updateAppAccount(conn, appClaims, signingKP)

	createSentinelCredentials(authClaims, signingKP)

	return &accountConfig{
		authClaims: authClaims,
		appClaims:  appClaims,
		signingKP:  signingKP,
		authUserKP: authUserKP,
	}
}
```

**Step 3: Modify ensureAppAccountExists to use KMS key**

Change `ensureAppAccountExists` at `authservice.go:311` to accept and use the optional KMS key:

```go
func ensureAppAccountExists(conn *natsConnection, appJWT, appAccountName string, appAccountKey *KMSKey) *jwt.AccountClaims {
	if appJWT != "" {
		appClaims, err := jwt.DecodeAccountClaims(appJWT)
		if err != nil {
			log.Fatalf("Failed to decode APP account JWT: %v", err)
		}
		// If KMS key is configured, verify the existing account matches
		if appAccountKey != nil && appClaims.Subject != appAccountKey.PublicKey {
			log.Fatalf("APP account public key mismatch: NATS has %s, KMS has %s. "+
				"This likely means the APP account was created with a different key. "+
				"Delete the existing APP account JWT from the resolver and restart.",
				appClaims.Subject, appAccountKey.PublicKey)
		}
		return appClaims
	}

	log.Println("APP account not found, creating new APP account...")

	var appPubKey string
	if appAccountKey != nil {
		// Use the stable KMS-backed key
		appPubKey = appAccountKey.PublicKey
		log.Printf("  APP account public key (from KMS): %s", appPubKey)
	} else {
		// Fallback: ephemeral key (original behaviour)
		appKP, err := nkeys.CreateAccount()
		if err != nil {
			log.Fatalf("Failed to create APP account keypair: %v", err)
		}
		appPubKey, err = appKP.PublicKey()
		if err != nil {
			log.Fatalf("Failed to get APP account public key: %v", err)
		}
		log.Printf("  APP account public key (ephemeral): %s", appPubKey)
	}

	appClaims := jwt.NewAccountClaims(appPubKey)
	appClaims.Name = appAccountName
	appClaims.IssuedAt = time.Now().Unix()

	appJWT, err := appClaims.EncodeWithSigner(conn.operatorKP, conn.operatorSigner)
	if err != nil {
		log.Fatalf("Failed to encode APP account JWT: %v", err)
	}
	log.Println("  APP account JWT created")

	updateSubject := "$SYS.REQ.CLAIMS.UPDATE"
	updateResp, err := conn.nc.Request(updateSubject, []byte(appJWT), 5*time.Second)
	if err != nil {
		log.Fatalf("Failed to publish APP account JWT: %v", err)
	}
	log.Printf("  Response from server: %s", string(updateResp.Data))
	log.Println()

	return appClaims
}
```

**Step 4: Verify it compiles and tests pass**

Run: `go build ./cmd/server/ && go test ./... -v`
Expected: Compiles cleanly, all tests pass (existing + new)

**Step 5: Commit**

```bash
git add cmd/server/authservice.go
git commit -m "feat: support KMS-backed APP account key in auth service"
```

---

### Task 5: Update design doc and verify end-to-end

**Files:**
- Modify: `docs/2026-02-17-nack-authentication-design.md` — mark as implemented, add final CLI usage

**Step 1: Run full test suite**

Run: `go test ./... -v -count=1`
Expected: All tests pass

**Step 2: Verify build**

Run: `go build -o /dev/null ./cmd/server/`
Expected: Clean build

**Step 3: Verify CLI help shows new flags**

Run: `go run ./cmd/server/ --help 2>&1`
Expected: Output includes `--generate-credentials`, `--app-account-key-alias`

**Step 4: Update design doc with final CLI usage**

Add a "Usage" section to the design doc showing the actual commands:

```
## CLI Usage

### Generate NACK credentials
./nats-aws-auth --generate-credentials --app-account-key-alias nats-app-account --output .

### Run auth service with stable APP account key
./nats-aws-auth --app-account-key-alias nats-app-account
```

**Step 5: Commit**

```bash
git add docs/2026-02-17-nack-authentication-design.md
git commit -m "docs: update design doc with final CLI usage"
```
